pip install selenium

Selenium relies on a webdriver to interact with specific browsers. 
Download the appropriate webdriver for your browser from
 https://www.selenium.dev/downloads/ and place it in your project directory.

2. Script Structure:

Here's a basic structure for the Python script:

from selenium import webdriver
from selenium.webdriver.common.by import By

# Define predefined values
value_X = "extract"
value_Y = "name"
value_Z = "data.txt"

# Path to your webdriver (e.g., chromedriver.exe)
driver_path = "path/to/your/webdriver"

# Create a new browser session
driver = webdriver.Chrome(executable_path=driver_path)

# Open the target webpage
driver.get("https://xyz_test.com")

# Locate and fill text fields
# Replace with specific locators for X, Y, and Z fields (explained below)
field_X = driver.find_element(By.ID, "field_X_id")  # Replace with actual ID
field_Y = driver.find_element(By.NAME, "field_Y_name")  # Replace with actual name
field_Z = driver.find_element(By.CSS_SELECTOR, "input[placeholder='data']")  # Replace with locator

field_X.send_keys(value_X)
field_Y.send_keys(value_Y)
field_Z.send_keys(value_Z)

# Additional actions (optional)
# ... submit form, etc.

# Close the browser
driver.quit()

3. Locating Text Fields:

There are various ways to locate elements on a webpage using Selenium. Here are some common methods:

By.ID: Use the element's unique ID attribute (field_X.find_element(By.ID, "field_X_id")).
By.NAME: Use the element's name attribute (field_Y.find_element(By.NAME, "field_Y_name")).
By.CSS_SELECTOR: Use a CSS selector targeting the element (field_Z.find_element(By.CSS_SELECTOR, "input[placeholder='data']")).
Important: Replace the placeholder values in the script with the actual locators
 for fields X, Y, and Z on your specific webpage. 
 You can use your browser's developer tools to inspect the elements and identify their attributes.

4. Additional Notes:

This script opens the webpage in a new browser window controlled by Selenium.
Consider error handling for situations where elements are not found.
This is a basic example. You might need to adapt it based on the complexity of the webpage and form submission process.



You can modify the script to be interactive and run multiple tests with different values. 
Here's how:

from selenium import webdriver
from selenium.webdriver.common.by import By

# Define test data as a list of dictionaries
test_data = [
    {"X": "x1", "Y": "y1", "Z": "z1"},
    {"X": "x2", "Y": "y2", "Z": "z2"},
    # Add more test data dictionaries as needed
]

# Path to your webdriver
driver_path = "path/to/your/webdriver"

# Create a new browser session
driver = webdriver.Chrome(executable_path=driver_path)

# Loop through each test data
for test in range(len(test_data)):
  print(f"\nstart test {test+1}")

  # Access test data for current test
  current_test = test_data[test]
  value_X = current_test["X"]
  value_Y = current_test["Y"]
  value_Z = current_test["Z"]

  # Open the target webpage
  driver.get("https://xyz_test.com")

  # Locate and fill text fields
  field_X = driver.find_element(By.ID, "field_X_id")  # Replace with actual ID
  field_Y = driver.find_element(By.NAME, "field_Y_name")  # Replace with actual name
  field_Z = driver.find_element(By.CSS_SELECTOR, "input[placeholder='data']")  # Replace with locator

  field_X.send_keys(value_X)
  field_Y.send_keys(value_Y)
  field_Z.send_keys(value_Z)

  # Additional actions (optional)
  # ... submit form, etc.

  # Wait for user input before proceeding (optional)
  input("Press Enter to continue...")

  print(f"end test {test+1}")

# Close the browser
driver.quit()

print("\nend all tests")


Explanation:

We define a list named test_data containing dictionaries. Each dictionary represents a single test with keys for X, Y, and Z values.
The script iterates through each test dictionary using a loop.
Inside the loop, it extracts the current test's data and assigns it to variables.
The script continues filling the form and performing other actions as before.
You can optionally add an input statement to pause before continuing to the next test, allowing you to visually inspect the results.
Additional Tips:

You can enhance the script by adding error handling for cases where elements are not found or if the form submission fails.
Consider storing test data in a separate file (e.g., JSON or CSV) for easier maintenance and adding more tests without modifying the script itself.




https://github.com/search?q=test+with+selenium&type=repositories 

https://github.com/jobeasy-team/python-selenium-automation/blob/master/features/steps/product_search.py 

https://www.browserstack.com/guide/python-selenium-to-run-web-automation-test 
















